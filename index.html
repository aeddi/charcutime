<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Charcutime - Charcuterie Drying Tracker</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --surface2: #0f3460;
    --accent: #e94560;
    --text: #eee;
    --text-muted: #999;
    --radius: 8px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  header {
    background: var(--surface);
    padding: 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 2px solid var(--accent);
  }

  header h1 {
    font-size: 1.6rem;
    font-weight: 700;
    letter-spacing: 1px;
  }

  header h1 span { color: var(--accent); }

  .header-actions { display: flex; gap: 8px; }

  button {
    background: var(--surface2);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 8px 14px;
    border-radius: var(--radius);
    cursor: pointer;
    font-size: 0.85rem;
    transition: background 0.2s;
  }

  button:hover { background: #1a4a80; }

  button.primary {
    background: var(--accent);
    border-color: var(--accent);
  }

  button.primary:hover { background: #c73a52; }

  button.danger { background: #6b1a1a; border-color: #8b2a2a; }
  button.danger:hover { background: #8b2a2a; }

  .app {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  .sidebar {
    width: 340px;
    min-width: 340px;
    background: var(--surface);
    padding: 16px;
    overflow-y: auto;
    border-right: 1px solid rgba(255,255,255,0.05);
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .sidebar h2 {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .item-card {
    background: var(--bg);
    border-radius: var(--radius);
    padding: 12px;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.05);
    transition: border-color 0.2s;
  }

  .item-card:hover { border-color: rgba(255,255,255,0.15); }
  .item-card.expanded { border-color: rgba(255,255,255,0.2); }

  .item-header {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .color-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .item-name {
    font-weight: 600;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .item-summary {
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-top: 4px;
    padding-left: 24px;
  }

  .item-details {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.05);
  }

  .item-info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
    font-size: 0.8rem;
    margin-bottom: 12px;
  }

  .item-info dt { color: var(--text-muted); }
  .item-info dd { font-weight: 600; text-align: right; }

  .measurements-list {
    max-height: 160px;
    overflow-y: auto;
    margin-bottom: 10px;
  }

  .measurement-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    font-size: 0.8rem;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }

  .measurement-row .date { color: var(--text-muted); }
  .measurement-row .delete-m {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    padding: 2px 6px;
    font-size: 0.75rem;
  }
  .measurement-row .delete-m:hover { color: var(--accent); }

  .add-measurement-form {
    display: flex;
    gap: 6px;
    margin-bottom: 8px;
  }

  .add-measurement-form input {
    flex: 1;
    min-width: 0;
  }

  input, select {
    background: var(--surface2);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 7px 10px;
    border-radius: var(--radius);
    font-size: 0.85rem;
  }

  input:focus, select:focus {
    outline: none;
    border-color: var(--accent);
  }

  .main {
    flex: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
    min-width: 0;
  }

  .chart-container {
    flex: 1;
    position: relative;
    min-height: 300px;
  }

  .chart-container canvas {
    width: 100% !important;
    height: 100% !important;
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: var(--text-muted);
    gap: 12px;
    font-size: 1.1rem;
  }

  /* Modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .modal-overlay.active { display: flex; }

  .modal {
    background: var(--surface);
    border-radius: 12px;
    padding: 24px;
    width: 380px;
    max-width: 90vw;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .modal h3 {
    margin-bottom: 16px;
    font-size: 1.1rem;
  }

  .form-group {
    margin-bottom: 12px;
  }

  .form-group label {
    display: block;
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-bottom: 4px;
  }

  .form-group input {
    width: 100%;
  }

  .modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 18px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .app { flex-direction: column; }
    .sidebar {
      width: 100%;
      min-width: 0;
      max-height: 40vh;
      border-right: none;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
  }
</style>
</head>
<body>

<header>
  <h1>Charcu<span>time</span></h1>
  <div class="header-actions">
    <button onclick="exportData()">Export</button>
    <button onclick="document.getElementById('importInput').click()">Import</button>
    <input type="file" id="importInput" accept=".json" style="display:none" onchange="importData(event)">
  </div>
</header>

<div class="app">
  <aside class="sidebar">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <h2>Items</h2>
      <button class="primary" onclick="openAddModal()">+ Add</button>
    </div>
    <div id="itemList"></div>
  </aside>

  <main class="main">
    <div class="chart-container">
      <canvas id="chart"></canvas>
      <div class="empty-state" id="emptyState">
        <div style="font-size:2.5rem;">ðŸ¥©</div>
        <div>Add a charcuterie item to get started</div>
      </div>
    </div>
  </main>
</div>

<!-- Add Item Modal -->
<div class="modal-overlay" id="addModal">
  <div class="modal">
    <h3 id="modalTitle">Add New Item</h3>
    <div class="form-group">
      <label>Name</label>
      <input type="text" id="inputName" placeholder="e.g. Saucisson sec">
    </div>
    <div class="form-group">
      <label>Initial Weight (g)</label>
      <input type="number" id="inputWeight" min="1" step="any" placeholder="500">
    </div>
    <div class="form-group">
      <label>Start Date</label>
      <input type="date" id="inputDate">
    </div>
    <div class="form-group">
      <label>Target Weight Loss (%)</label>
      <input type="number" id="inputTarget" min="1" max="90" step="any" placeholder="35">
    </div>
    <div class="modal-actions">
      <button onclick="closeAddModal()">Cancel</button>
      <button class="primary" onclick="saveItem()">Save</button>
    </div>
  </div>
</div>

<script>
const COLORS = [
  '#e63946','#457b9d','#2a9d8f','#e9c46a','#f4a261',
  '#264653','#a8dadc','#d62828','#6a994e','#bc6c25',
  '#606c38','#283618','#dda15e','#8338ec','#3a86ff',
];

const STORAGE_KEY = 'charcutime_data';

let data = { items: [] };
let expandedId = null;
let chart = null;
let editingId = null;

// â”€â”€ Persistence â”€â”€

function load() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) data = JSON.parse(raw);
  } catch { data = { items: [] }; }
}

function save() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

// â”€â”€ Color assignment â”€â”€

function nextColor() {
  const used = new Set(data.items.map(i => i.color));
  return COLORS.find(c => !used.has(c)) || COLORS[data.items.length % COLORS.length];
}

// â”€â”€ UUID â”€â”€

function uuid() {
  return crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2) + Date.now().toString(36);
}

// â”€â”€ Calculations â”€â”€

function lossPercent(item, weight) {
  return ((item.initialWeight - weight) / item.initialWeight) * 100;
}

function daysBetween(a, b) {
  return (new Date(b) - new Date(a)) / 86400000;
}

function linearRegression(points) {
  // points: [{x: days, y: lossPercent}]
  const n = points.length;
  if (n < 2) return null;
  let sx = 0, sy = 0, sxy = 0, sxx = 0;
  for (const p of points) {
    sx += p.x; sy += p.y; sxy += p.x * p.y; sxx += p.x * p.x;
  }
  const denom = n * sxx - sx * sx;
  if (denom === 0) return null;
  const slope = (n * sxy - sx * sy) / denom;
  const intercept = (sy - slope * sx) / n;
  return { slope, intercept };
}

function estimateCompletion(item) {
  const allPoints = [{ x: 0, y: 0 }];
  const sorted = [...item.measurements].sort((a, b) => a.date.localeCompare(b.date));
  for (const m of sorted) {
    allPoints.push({
      x: daysBetween(item.initialDate, m.date),
      y: lossPercent(item, m.weight),
    });
  }
  const reg = linearRegression(allPoints);
  if (!reg || reg.slope <= 0) return null;
  const daysToTarget = (item.targetLossPercent - reg.intercept) / reg.slope;
  const estDate = new Date(new Date(item.initialDate).getTime() + daysToTarget * 86400000);
  return { daysToTarget, estDate, reg };
}

// â”€â”€ Export / Import â”€â”€

function exportData() {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'charcutime_backup.json';
  a.click();
  URL.revokeObjectURL(a.href);
}

function importData(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const imported = JSON.parse(e.target.result);
      if (imported.items && Array.isArray(imported.items)) {
        data = imported;
        save();
        render();
      } else {
        alert('Invalid file format.');
      }
    } catch {
      alert('Failed to parse JSON file.');
    }
  };
  reader.readAsText(file);
  event.target.value = '';
}

// â”€â”€ Modal â”€â”€

function openAddModal(id) {
  editingId = id || null;
  const modal = document.getElementById('addModal');
  document.getElementById('modalTitle').textContent = id ? 'Edit Item' : 'Add New Item';
  if (id) {
    const item = data.items.find(i => i.id === id);
    document.getElementById('inputName').value = item.name;
    document.getElementById('inputWeight').value = item.initialWeight;
    document.getElementById('inputDate').value = item.initialDate;
    document.getElementById('inputTarget').value = item.targetLossPercent;
  } else {
    document.getElementById('inputName').value = '';
    document.getElementById('inputWeight').value = '';
    document.getElementById('inputDate').value = new Date().toISOString().slice(0, 10);
    document.getElementById('inputTarget').value = '35';
  }
  modal.classList.add('active');
  document.getElementById('inputName').focus();
}

function closeAddModal() {
  document.getElementById('addModal').classList.remove('active');
  editingId = null;
}

function saveItem() {
  const name = document.getElementById('inputName').value.trim();
  const weight = parseFloat(document.getElementById('inputWeight').value);
  const date = document.getElementById('inputDate').value;
  const target = parseFloat(document.getElementById('inputTarget').value);

  if (!name || !weight || !date || !target) {
    alert('Please fill in all fields.');
    return;
  }

  if (editingId) {
    const item = data.items.find(i => i.id === editingId);
    item.name = name;
    item.initialWeight = weight;
    item.initialDate = date;
    item.targetLossPercent = target;
  } else {
    data.items.push({
      id: uuid(),
      name,
      color: nextColor(),
      initialWeight: weight,
      initialDate: date,
      targetLossPercent: target,
      measurements: [],
    });
  }
  save();
  closeAddModal();
  render();
}

// â”€â”€ Item actions â”€â”€

function deleteItem(id) {
  if (!confirm('Delete this item and all its measurements?')) return;
  data.items = data.items.filter(i => i.id !== id);
  if (expandedId === id) expandedId = null;
  save();
  render();
}

function addMeasurement(id) {
  const dateInput = document.getElementById(`mdate-${id}`);
  const weightInput = document.getElementById(`mweight-${id}`);
  const date = dateInput.value;
  const weight = parseFloat(weightInput.value);
  if (!date || !weight) return;

  const item = data.items.find(i => i.id === id);
  item.measurements.push({ date, weight });
  item.measurements.sort((a, b) => a.date.localeCompare(b.date));
  save();
  render();
}

function deleteMeasurement(itemId, idx) {
  const item = data.items.find(i => i.id === itemId);
  item.measurements.splice(idx, 1);
  save();
  render();
}

// â”€â”€ Render sidebar â”€â”€

function renderSidebar() {
  const container = document.getElementById('itemList');
  if (data.items.length === 0) {
    container.innerHTML = '<div style="color:var(--text-muted);font-size:0.85rem;padding:12px 0;">No items yet. Click "+ Add" to start tracking.</div>';
    return;
  }

  container.innerHTML = data.items.map(item => {
    const sorted = [...item.measurements].sort((a, b) => a.date.localeCompare(b.date));
    const lastM = sorted.length ? sorted[sorted.length - 1] : null;
    const currentLoss = lastM ? lossPercent(item, lastM.weight).toFixed(1) : '0.0';
    const currentWeight = lastM ? lastM.weight : item.initialWeight;
    const est = estimateCompletion(item);
    const isExpanded = expandedId === item.id;

    let detailsHtml = '';
    if (isExpanded) {
      const estText = est
        ? `${est.estDate.toLocaleDateString()}`
        : (sorted.length < 1 ? 'Need measurements' : 'Not converging');

      detailsHtml = `
        <div class="item-details" onclick="event.stopPropagation()">
          <dl class="item-info">
            <dt>Initial</dt><dd>${item.initialWeight}g</dd>
            <dt>Current</dt><dd>${currentWeight}g</dd>
            <dt>Loss</dt><dd>${currentLoss}%</dd>
            <dt>Target</dt><dd>${item.targetLossPercent}% (${(item.initialWeight * (1 - item.targetLossPercent / 100)).toFixed(0)}g)</dd>
            <dt>Start</dt><dd>${item.initialDate}</dd>
            <dt>Est. done</dt><dd>${estText}</dd>
          </dl>
          <div style="font-size:0.8rem;color:var(--text-muted);margin-bottom:6px;">Measurements</div>
          <div class="measurements-list">
            ${sorted.map((m, idx) => `
              <div class="measurement-row">
                <span class="date">${m.date}</span>
                <span>${m.weight}g (${lossPercent(item, m.weight).toFixed(1)}%)</span>
                <button class="delete-m" onclick="deleteMeasurement('${item.id}',${idx})" title="Delete">&times;</button>
              </div>
            `).join('')}
            ${sorted.length === 0 ? '<div style="font-size:0.8rem;color:var(--text-muted);padding:4px 0;">No measurements yet.</div>' : ''}
          </div>
          <div class="add-measurement-form">
            <input type="date" id="mdate-${item.id}" value="${new Date().toISOString().slice(0, 10)}">
            <input type="number" id="mweight-${item.id}" placeholder="Weight (g)" min="1" step="any" style="width:100px;">
            <button onclick="addMeasurement('${item.id}')">Add</button>
          </div>
          <div style="display:flex;gap:6px;margin-top:4px;">
            <button onclick="openAddModal('${item.id}')" style="flex:1;">Edit</button>
            <button class="danger" onclick="deleteItem('${item.id}')" style="flex:1;">Delete</button>
          </div>
        </div>
      `;
    }

    return `
      <div class="item-card ${isExpanded ? 'expanded' : ''}" onclick="toggleExpand('${item.id}')">
        <div class="item-header">
          <div class="color-dot" style="background:${item.color}"></div>
          <div class="item-name">${escapeHtml(item.name)}</div>
          <div style="font-size:0.8rem;color:var(--text-muted);">${currentLoss}%</div>
        </div>
        <div class="item-summary">${item.initialWeight}g &rarr; target &minus;${item.targetLossPercent}% (${(item.initialWeight * (1 - item.targetLossPercent / 100)).toFixed(0)}g)</div>
        ${detailsHtml}
      </div>
    `;
  }).join('');
}

function escapeHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function toggleExpand(id) {
  expandedId = expandedId === id ? null : id;
  renderSidebar();
}

// â”€â”€ Chart â”€â”€

function renderChart() {
  const empty = document.getElementById('emptyState');
  const hasData = data.items.length > 0;
  empty.style.display = hasData ? 'none' : 'flex';

  if (!hasData) {
    if (chart) { chart.destroy(); chart = null; }
    return;
  }

  const datasets = [];
  let allDates = [];

  for (const item of data.items) {
    const sorted = [...item.measurements].sort((a, b) => a.date.localeCompare(b.date));

    // Actual data points (starting from initial date at 0%)
    const points = [{ x: item.initialDate, y: 0 }];
    for (const m of sorted) {
      points.push({ x: m.date, y: parseFloat(lossPercent(item, m.weight).toFixed(2)) });
    }
    allDates.push(item.initialDate, ...sorted.map(m => m.date));

    // Main line
    datasets.push({
      label: item.name,
      data: points,
      borderColor: item.color,
      backgroundColor: item.color + '33',
      borderWidth: 2.5,
      pointRadius: 4,
      pointHoverRadius: 6,
      tension: 0.1,
      fill: false,
      itemId: item.id,
    });

    // Target horizontal dashed line
    const minDate = item.initialDate;
    const est = estimateCompletion(item);
    const maxDate = est && est.estDate > new Date()
      ? est.estDate.toISOString().slice(0, 10)
      : (sorted.length ? sorted[sorted.length - 1].date : item.initialDate);

    // Extend target line well past the last date
    const targetEndDate = new Date(Math.max(
      new Date(maxDate).getTime(),
      Date.now() + 30 * 86400000
    )).toISOString().slice(0, 10);

    allDates.push(targetEndDate);

    datasets.push({
      label: `${item.name} target`,
      data: [
        { x: minDate, y: item.targetLossPercent },
        { x: targetEndDate, y: item.targetLossPercent },
      ],
      borderColor: item.color,
      borderWidth: 1.5,
      borderDash: [6, 4],
      pointRadius: 0,
      pointHoverRadius: 0,
      fill: false,
      hidden: false,
    });

    // Projection line
    if (est && est.reg.slope > 0 && sorted.length >= 1) {
      const lastPoint = points[points.length - 1];
      const projEndDate = est.estDate.toISOString().slice(0, 10);

      // Only draw projection if the estimated date is after the last measurement
      if (projEndDate > lastPoint.x) {
        allDates.push(projEndDate);
        datasets.push({
          label: `${item.name} projection`,
          data: [
            { x: lastPoint.x, y: lastPoint.y },
            { x: projEndDate, y: item.targetLossPercent },
          ],
          borderColor: item.color + '88',
          borderWidth: 2,
          borderDash: [4, 4],
          pointRadius: [0, 4],
          pointStyle: 'crossRot',
          fill: false,
        });
      }
    }
  }

  const config = {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        intersect: false,
      },
      scales: {
        x: {
          type: 'time',
          time: { unit: 'day', tooltipFormat: 'PP' },
          title: { display: true, text: 'Date', color: '#999' },
          grid: { color: 'rgba(255,255,255,0.05)' },
          ticks: { color: '#999' },
        },
        y: {
          title: { display: true, text: 'Weight Loss %', color: '#999' },
          beginAtZero: true,
          grid: { color: 'rgba(255,255,255,0.05)' },
          ticks: { color: '#999', callback: v => v + '%' },
        },
      },
      plugins: {
        legend: {
          labels: {
            color: '#ccc',
            filter: (legendItem) => {
              return !legendItem.text.includes('target') && !legendItem.text.includes('projection');
            },
          },
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const ds = context.dataset;
              if (ds.label.includes('target')) {
                return `${ds.label}: ${context.parsed.y}%`;
              }
              if (ds.label.includes('projection')) {
                return `${ds.label}: ${context.parsed.y.toFixed(1)}%`;
              }
              // Find the item to show weight
              const item = data.items.find(i => i.id === ds.itemId);
              if (item) {
                const y = context.parsed.y;
                const weight = (item.initialWeight * (1 - y / 100)).toFixed(0);
                return `${item.name}: ${y.toFixed(1)}% loss (${weight}g)`;
              }
              return `${ds.label}: ${context.parsed.y.toFixed(1)}%`;
            },
          },
        },
      },
    },
  };

  if (chart) {
    chart.data = config.data;
    chart.options = config.options;
    chart.update();
  } else {
    chart = new Chart(document.getElementById('chart'), config);
  }
}

// â”€â”€ Main render â”€â”€

function render() {
  renderSidebar();
  renderChart();
}

// â”€â”€ Keyboard shortcut â”€â”€

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') closeAddModal();
});

// â”€â”€ Init â”€â”€

load();
render();
</script>
</body>
</html>
